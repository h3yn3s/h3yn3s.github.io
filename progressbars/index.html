<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Progress Bar Clicker</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      user-select: none;
    }
    body {
      background: #0a0a12;
      color: #fff;
      font-family: 'Segoe UI', system-ui, sans-serif;
      overflow: hidden;
      height: 100vh;
    }
    #game-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #top-bar {
      background: linear-gradient(180deg, #1a1a2e 0%, #12121f 100%);
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 2px solid #2a2a4a;
      flex-shrink: 0;
    }
    .stat {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }
    .stat-label {
      color: #666;
    }
    .stat-value {
      font-weight: bold;
      color: #4ecca3;
    }
    .stat-value.slots {
      color: #7eb8da;
    }
    .stat-value.shards {
      color: #e94560;
    }
    .stat-value.cooking {
      color: #ff9800;
      font-style: italic;
    }
    #combo-display {
      position: fixed;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 32px;
      font-weight: bold;
      color: #ff6b6b;
      text-shadow: 0 0 20px rgba(255, 107, 107, 0.8);
      opacity: 0;
      transition: opacity 0.2s, transform 0.2s;
      z-index: 100;
      pointer-events: none;
    }
    #combo-display.active {
      opacity: 1;
    }
    #combo-display.pulse {
      animation: combo-pulse 0.15s ease-out;
    }
    @keyframes combo-pulse {
      0% { transform: translateX(-50%) scale(1); }
      50% { transform: translateX(-50%) scale(1.3); }
      100% { transform: translateX(-50%) scale(1); }
    }
    #main-content {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    #play-area {
      flex: 1;
      background: radial-gradient(ellipse at center, #0f0f1a 0%, #0a0a12 100%);
      position: relative;
      overflow: hidden;
      cursor: crosshair;
    }
    #sidebar {
      width: 280px;
      background: linear-gradient(180deg, #1a1a2e 0%, #12121f 100%);
      border-left: 2px solid #2a2a4a;
      overflow-y: auto;
      flex-shrink: 0;
    }
    .sidebar-section {
      border-bottom: 1px solid #2a2a4a;
      padding: 12px;
    }
    .section-title {
      font-size: 11px;
      text-transform: uppercase;
      color: #666;
      margin-bottom: 10px;
      letter-spacing: 1px;
    }
    .upgrade-item, .unlock-item, .power-item {
      background: rgba(255,255,255,0.03);
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.15s;
      border: 1px solid rgba(255,255,255,0.08);
    }
    .upgrade-item:hover:not(.disabled):not(.maxed),
    .unlock-item:hover:not(.disabled):not(.unlocked),
    .power-item:hover:not(.disabled) {
      border-color: #4ecca3;
      background: rgba(78, 204, 163, 0.1);
    }
    .upgrade-item.disabled, .unlock-item.disabled, .power-item.disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .upgrade-item.maxed {
      opacity: 0.6;
      cursor: default;
      border-color: #4ecca3;
    }
    .unlock-item.unlocked {
      border-color: #4ecca3;
      cursor: default;
    }
    .item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }
    .item-name {
      font-weight: bold;
      font-size: 13px;
    }
    .item-level {
      font-size: 11px;
      color: #666;
    }
    .item-values {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      margin-bottom: 6px;
    }
    .current-value {
      color: #4ecca3;
    }
    .arrow {
      color: #444;
    }
    .next-value {
      color: #7eb8da;
    }
    .item-cost {
      font-size: 11px;
      color: #e94560;
    }
    .item-cost.affordable {
      color: #4ecca3;
    }
    .unlock-badge {
      background: #4ecca3;
      color: #0a0a12;
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 10px;
      font-weight: bold;
    }
    .item-description {
      font-size: 11px;
      color: #666;
      margin-top: 4px;
    }
    .power-timer {
      font-size: 11px;
      color: #ff9800;
      margin-top: 4px;
    }
    /* Progress bar styles */
    .progress-bar {
      position: absolute;
      height: 26px;
      border-radius: 4px;
      overflow: visible;
      border: 2px solid rgba(255,255,255,0.2);
      transition: border-color 0.1s;
      width: 140px;
    }
    .progress-bar-inner {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 2px;
      overflow: hidden;
      background: #1a1a2e;
    }
    .progress-bar.manual {
      border-color: rgba(126, 184, 218, 0.5);
    }
    .progress-bar.chain {
      border-color: rgba(78, 204, 163, 0.5);
    }
    .progress-bar.depth-2 {
      border-color: rgba(255, 193, 7, 0.6);
    }
    .progress-bar.depth-3 {
      border-color: rgba(255, 152, 0, 0.7);
    }
    .progress-bar.depth-4 {
      border-color: rgba(255, 87, 34, 0.8);
    }
    .progress-bar.depth-5 {
      border-color: rgba(233, 30, 99, 0.9);
    }
    .progress-bar.crit-flash {
      border-color: #ff5252 !important;
      box-shadow: 0 0 15px rgba(255, 82, 82, 0.8);
    }
    .bar-fill {
      height: 100%;
      transition: width 0.05s linear;
      position: relative;
    }
    .bar-fill.manual {
      background: linear-gradient(90deg, #5a8fba, #7eb8da);
    }
    .bar-fill.chain {
      background: linear-gradient(90deg, #3d9970, #4ecca3);
    }
    .bar-fill.depth-2 {
      background: linear-gradient(90deg, #f39c12, #f1c40f);
    }
    .bar-fill.depth-3 {
      background: linear-gradient(90deg, #e67e22, #ff9800);
    }
    .bar-fill.depth-4 {
      background: linear-gradient(90deg, #e74c3c, #ff5722);
    }
    .bar-fill.depth-5 {
      background: linear-gradient(90deg, #c0392b, #e91e63);
    }
    .depth-indicator {
      position: absolute;
      top: -18px;
      left: 4px;
      font-size: 10px;
      color: rgba(255,255,255,0.7);
      font-weight: bold;
    }
    .floating-text {
      position: absolute;
      font-weight: bold;
      pointer-events: none;
      animation: float-up 1.2s ease-out forwards;
      text-shadow: 0 2px 4px rgba(0,0,0,0.8);
      z-index: 50;
    }
    .floating-text.normal {
      color: #fff;
      font-size: 16px;
    }
    .floating-text.combo {
      color: #ff6b6b;
      font-size: 20px;
    }
    .floating-text.crit {
      color: #ff5252;
      font-size: 24px;
    }
    .floating-text.depth {
      color: #ffd700;
      font-size: 18px;
    }
    @keyframes float-up {
      0% { opacity: 1; transform: translateY(0) scale(1); }
      50% { opacity: 1; transform: translateY(-20px) scale(1.1); }
      100% { opacity: 0; transform: translateY(-50px) scale(0.8); }
    }
    .slot-full-indicator {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(233, 69, 96, 0.9);
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }
    .slot-full-indicator.show {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="top-bar">
      <div class="stat">
        <span class="stat-label">Bars:</span>
        <span class="stat-value" id="completed-bars">0</span>
      </div>
      <div class="stat">
        <span class="stat-label">Slots:</span>
        <span class="stat-value slots" id="manual-slots">0/3</span>
      </div>
      <div class="stat">
        <span class="stat-label">Active:</span>
        <span class="stat-value" id="active-bars">0</span>
      </div>
      <div class="stat">
        <span class="stat-label">Shards:</span>
        <span class="stat-value shards" id="chaos-shards">0</span>
      </div>
      <div class="stat">
        <span class="stat-label">Rate:</span>
        <span class="stat-value cooking" id="cooking-value">~0</span>
      </div>
    </div>
    <div id="combo-display">x1</div>
    <div id="main-content">
      <div id="play-area"></div>
      <div id="sidebar">
        <div class="sidebar-section" id="upgrades-section">
          <div class="section-title">Upgrades</div>
        </div>
        <div class="sidebar-section" id="unlocks-section">
          <div class="section-title">Special Bars</div>
        </div>
        <div class="sidebar-section" id="powers-section">
          <div class="section-title">Chaos Powers</div>
        </div>
      </div>
    </div>
  </div>
  <div class="slot-full-indicator" id="slot-indicator">Manual slots full! Wait for chains...</div>

<script>
// ============================================
// GAME STATE
// ============================================
let completedBars = 0;
let chaosShards = 0;
const MAX_ACTIVE_BARS = 150;
const QUEUE_TO_SHARDS_RATE = 5;

// Core stats
let baseFillTime = 10;        // 10 seconds base
let fillSpeedMultiplier = 1;  // multiplier for speed upgrades
let chainChance = 0.10;       // 10% starting chain chance!
let maxChainDepth = 1;
let barsPerCompletion = 1;
let maxManualSlots = 3;
let critChance = 0;
let critMultiplier = 2;

// Tracking
let manualBarsActive = 0;
let activeBars = [];

// Combo system
let comboCount = 0;
let lastCompletionTime = 0;
const COMBO_WINDOW = 1500; // 1.5 seconds to chain combos
let comboResetTimeout = null;

// Chaos power timers
let megaBoostTimer = 0;
let luckyStormCount = 0;

// ============================================
// LOCAL STORAGE
// ============================================
const SAVE_KEY = 'progressBarClicker_v1';

function saveGame() {
  const saveData = {
    completedBars,
    chaosShards,
    upgrades: {},
    unlocks: {}
  };

  for (const [key, upgrade] of Object.entries(upgrades)) {
    saveData.upgrades[key] = upgrade.currentLevel;
  }

  for (const [key, unlock] of Object.entries(specialBarUnlocks)) {
    saveData.unlocks[key] = unlock.unlocked;
  }

  localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
}

function loadGame() {
  const saved = localStorage.getItem(SAVE_KEY);
  if (!saved) return false;

  try {
    const data = JSON.parse(saved);

    completedBars = data.completedBars || 0;
    chaosShards = data.chaosShards || 0;

    // Restore upgrades
    for (let [key, level] of Object.entries(data.upgrades || {})) {
      // Backwards compat: old save key
      if (key === 'barsPerCompletion') key = 'baseValue';

      if (upgrades[key]) {
        upgrades[key].currentLevel = level;
        // Apply all levels up to current
        if (level > 0 && upgrades[key].levels[level - 1]) {
          upgrades[key].apply(upgrades[key].levels[level - 1].value);
        }
      }
    }

    // Restore unlocks
    for (const [key, unlocked] of Object.entries(data.unlocks || {})) {
      if (specialBarUnlocks[key]) {
        specialBarUnlocks[key].unlocked = unlocked;
      }
    }

    return true;
  } catch (e) {
    console.error('Failed to load save:', e);
    return false;
  }
}

function clearSave() {
  localStorage.removeItem(SAVE_KEY);
  location.reload();
}

// ============================================
// UPGRADES DEFINITION
// ============================================
const upgrades = {
  baseValue: {
    name: 'Base Value',
    currentLevel: 0,
    levels: [
      { cost: 10, value: 2 },
      { cost: 35, value: 3 },
      { cost: 100, value: 5 },
      { cost: 300, value: 8 },
      { cost: 900, value: 12 },
    ],
    getDisplay: (val) => val + ' bars',
    getCurrentValue: () => barsPerCompletion,
    apply: (val) => { barsPerCompletion = val; }
  },
  chainChance: {
    name: 'Chain Chance',
    currentLevel: 0,
    levels: [
      { cost: 15, value: 0.20 },   // 20%
      { cost: 40, value: 0.35 },   // 35%
      { cost: 100, value: 0.50 },  // 50%
      { cost: 250, value: 0.70 },  // 70%
      { cost: 600, value: 0.90 },  // 90%
      { cost: 1500, value: 1.10 }, // 110%
    ],
    getDisplay: (val) => Math.floor(val * 100) + '%',
    getCurrentValue: () => chainChance,
    apply: (val) => { chainChance = val; }
  },
  chainDepth: {
    name: 'Chain Depth',
    currentLevel: 0,
    levels: [
      { cost: 50, value: 2 },
      { cost: 200, value: 3 },
      { cost: 800, value: 4 },
      { cost: 3000, value: 5 },
    ],
    getDisplay: (val) => 'Depth ' + val,
    getCurrentValue: () => maxChainDepth,
    apply: (val) => { maxChainDepth = val; }
  },
  manualSlots: {
    name: 'Manual Slots',
    currentLevel: 0,
    levels: [
      { cost: 25, value: 4 },
      { cost: 80, value: 5 },
      { cost: 200, value: 7 },
      { cost: 500, value: 10 },
    ],
    getDisplay: (val) => val + ' slots',
    getCurrentValue: () => maxManualSlots,
    apply: (val) => { maxManualSlots = val; }
  },
  fillSpeed: {
    name: 'Fill Speed',
    currentLevel: 0,
    levels: [
      { cost: 60, value: 1.3 },   // 7.7s
      { cost: 200, value: 1.7 },  // 5.9s
      { cost: 600, value: 2.2 },  // 4.5s
      { cost: 2000, value: 3.0 }, // 3.3s
    ],
    getDisplay: (val) => (baseFillTime / val).toFixed(1) + 's',
    getCurrentValue: () => fillSpeedMultiplier,
    apply: (val) => { fillSpeedMultiplier = val; }
  },
  critChance: {
    name: 'Crit Chance',
    currentLevel: 0,
    levels: [
      { cost: 100, value: 0.08 },
      { cost: 400, value: 0.18 },
      { cost: 1500, value: 0.30 },
    ],
    getDisplay: (val) => Math.floor(val * 100) + '%',
    getCurrentValue: () => critChance,
    apply: (val) => { critChance = val; }
  },
};

// ============================================
// SPECIAL BAR UNLOCKS
// ============================================
const specialBarUnlocks = {
  boostBar: {
    name: 'Boost Bars',
    cost: 300,
    unlocked: false,
    spawnChance: 0.05,
    description: 'Gold bars that 2x all active bar speeds'
  },
  cascadeBar: {
    name: 'Cascade Bars',
    cost: 1000,
    unlocked: false,
    spawnChance: 0.04,
    description: 'Rainbow bars that guarantee max depth chains'
  },
};

// ============================================
// CHAOS POWERS
// ============================================
const chaosPowers = {
  completeAll: {
    name: 'Complete All',
    cost: 100,
    description: 'Instantly finish all active bars',
    activate: () => {
      for (let bar of activeBars) {
        if (!bar.completed) bar.progress = 1;
      }
    }
  },
  megaBoost: {
    name: 'Mega Boost',
    cost: 50,
    description: '3x bars earned for 30 seconds',
    activate: () => { megaBoostTimer = 30; }
  },
  luckyStorm: {
    name: 'Lucky Storm',
    cost: 75,
    description: 'Next 10 completions guarantee chains',
    activate: () => { luckyStormCount = 10; }
  },
};

// ============================================
// COMBO SYSTEM
// ============================================
function registerCompletion() {
  const now = performance.now();

  if (now - lastCompletionTime < COMBO_WINDOW) {
    comboCount++;
  } else {
    comboCount = 1;
  }

  lastCompletionTime = now;

  // Reset combo after window expires
  if (comboResetTimeout) clearTimeout(comboResetTimeout);
  comboResetTimeout = setTimeout(() => {
    comboCount = 0;
    updateComboDisplay();
  }, COMBO_WINDOW);

  updateComboDisplay();
  return comboCount;
}

function getComboMultiplier() {
  if (comboCount <= 1) return 1;
  // Combo multiplier: 1, 1.5, 2, 2.5, 3, 3.5...
  return 1 + (comboCount - 1) * 0.5;
}

function updateComboDisplay() {
  const display = document.getElementById('combo-display');
  if (comboCount > 1) {
    display.textContent = 'x' + getComboMultiplier().toFixed(1);
    display.classList.add('active');
    display.classList.remove('pulse');
    void display.offsetWidth; // trigger reflow
    display.classList.add('pulse');
  } else {
    display.classList.remove('active');
  }
}

// ============================================
// CHAIN DAMPENING
// ============================================
function getEffectiveChainChance(depth) {
  if (luckyStormCount > 0) return 1.0;
  const dampening = Math.pow(0.7, depth);
  return chainChance * dampening;
}

// ============================================
// BAR CREATION & MANAGEMENT
// ============================================
function determineBarType() {
  const roll = Math.random();
  let cumulative = 0;

  if (specialBarUnlocks.cascadeBar.unlocked) {
    cumulative += specialBarUnlocks.cascadeBar.spawnChance;
    if (roll < cumulative) return 'cascade';
  }
  if (specialBarUnlocks.boostBar.unlocked) {
    cumulative += specialBarUnlocks.boostBar.spawnChance;
    if (roll < cumulative) return 'boost';
  }
  return 'normal';
}

function createBar(x, y, depth = 0, isManual = false) {
  // Check manual slot limit
  if (isManual) {
    if (manualBarsActive >= maxManualSlots) {
      showSlotFullIndicator();
      return null;
    }
    manualBarsActive++;
  }

  // Check total bar limit
  if (activeBars.length >= MAX_ACTIVE_BARS) {
    chaosShards += QUEUE_TO_SHARDS_RATE;
    updateUI();
    return null;
  }

  const playArea = document.getElementById('play-area');
  const rect = playArea.getBoundingClientRect();

  // Clamp position
  x = Math.max(10, Math.min(x, rect.width - 150));
  y = Math.max(10, Math.min(y, rect.height - 36));

  const barType = determineBarType();
  const depthClass = depth > 1 ? `depth-${Math.min(depth, 5)}` : (isManual ? 'manual' : 'chain');

  const bar = document.createElement('div');
  bar.className = `progress-bar ${depthClass}`;
  if (barType === 'boost') bar.classList.add('boost-bar');
  if (barType === 'cascade') bar.classList.add('cascade-bar');
  bar.style.left = x + 'px';
  bar.style.top = y + 'px';

  const inner = document.createElement('div');
  inner.className = 'progress-bar-inner';
  bar.appendChild(inner);

  const fill = document.createElement('div');
  fill.className = `bar-fill ${depthClass}`;
  fill.style.width = '0%';
  inner.appendChild(fill);

  if (depth > 0) {
    const depthIndicator = document.createElement('span');
    depthIndicator.className = 'depth-indicator';
    depthIndicator.textContent = 'd' + depth;
    bar.appendChild(depthIndicator);
  }

  playArea.appendChild(bar);

  // Speed variance: ±15%
  const variance = 0.85 + Math.random() * 0.30;
  const effectiveFillTime = baseFillTime / fillSpeedMultiplier * variance;

  const barData = {
    element: bar,
    fill: fill,
    progress: 0,
    type: barType,
    depth: depth,
    isManual: isManual,
    x: x,
    y: y,
    completed: false,
    fillTime: effectiveFillTime,
    fillRate: 1 / effectiveFillTime, // progress per second
  };

  activeBars.push(barData);
  updateUI();
  return barData;
}

function completeBar(bar) {
  if (bar.completed) return;
  bar.completed = true;

  // Register for combo
  const combo = registerCompletion();
  const comboMult = getComboMultiplier();

  // Calculate depth bonus: depth 1 = 1x, depth 2 = 1.5x, depth 3 = 2x, etc.
  const depthBonus = 1 + (bar.depth * 0.5);

  // Base earning
  let earned = barsPerCompletion * depthBonus * comboMult;
  let isCrit = false;

  // Crit check
  if (Math.random() < critChance) {
    earned *= critMultiplier;
    isCrit = true;
    bar.element.classList.add('crit-flash');
  }

  // Mega boost
  if (megaBoostTimer > 0) {
    earned *= 3;
  }

  earned = Math.floor(earned);
  completedBars += earned;

  // Floating text
  const textType = isCrit ? 'crit' : (combo > 1 ? 'combo' : (bar.depth > 0 ? 'depth' : 'normal'));
  spawnFloatingText(bar.x + 70, bar.y, '+' + earned, textType);

  // Special bar effects
  if (bar.type === 'boost') {
    for (let b of activeBars) {
      if (!b.completed) {
        b.fillRate *= 2;
      }
    }
    spawnFloatingText(bar.x + 70, bar.y - 20, 'BOOST!', 'depth');
  } else if (bar.type === 'cascade') {
    // Cascade guarantees max chains
    bar.cascadeChain = true;
    spawnFloatingText(bar.x + 70, bar.y - 20, 'CASCADE!', 'crit');
  }

  // Roll for chains
  rollChains(bar);

  // Track manual slot
  if (bar.isManual) {
    manualBarsActive--;
  }

  // Lucky storm tracking
  if (luckyStormCount > 0) {
    luckyStormCount--;
  }

  // Remove bar
  setTimeout(() => {
    bar.element.remove();
    const idx = activeBars.indexOf(bar);
    if (idx > -1) activeBars.splice(idx, 1);
    updateUI();
  }, 150);

  updateUI();
}

function rollChains(bar) {
  if (bar.depth >= maxChainDepth) return;

  let effectiveChance = bar.cascadeChain ? maxChainDepth : getEffectiveChainChance(bar.depth);
  if (bar.cascadeChain) effectiveChance = 1.0; // guarantee chain

  // Calculate chains to spawn
  let chainsToSpawn = Math.floor(effectiveChance);
  const remainingChance = effectiveChance % 1;

  if (Math.random() < remainingChance) {
    chainsToSpawn++;
  }

  // Cascade bars spawn multiple chains
  if (bar.cascadeChain) {
    chainsToSpawn = Math.max(chainsToSpawn, 2);
  }

  const playArea = document.getElementById('play-area');
  const rect = playArea.getBoundingClientRect();

  for (let i = 0; i < chainsToSpawn; i++) {
    // Spawn near parent for visual cascade effect
    const offsetX = (Math.random() - 0.5) * 200;
    const offsetY = (Math.random() - 0.5) * 100 + 40;
    let newX = bar.x + offsetX;
    let newY = bar.y + offsetY;

    // Clamp to play area
    newX = Math.max(10, Math.min(newX, rect.width - 150));
    newY = Math.max(10, Math.min(newY, rect.height - 36));

    // Small delay for visual effect
    setTimeout(() => {
      const newBar = createBar(newX, newY, bar.depth + 1, false);
      if (newBar && bar.cascadeChain) {
        newBar.cascadeChain = true; // propagate cascade
      }
    }, i * 50);
  }
}

function spawnFloatingText(x, y, text, type = 'normal') {
  const playArea = document.getElementById('play-area');
  const ft = document.createElement('div');
  ft.className = `floating-text ${type}`;
  ft.textContent = text;
  ft.style.left = x + 'px';
  ft.style.top = y + 'px';
  playArea.appendChild(ft);

  setTimeout(() => ft.remove(), 1200);
}

function showSlotFullIndicator() {
  const indicator = document.getElementById('slot-indicator');
  indicator.classList.add('show');
  setTimeout(() => indicator.classList.remove('show'), 1500);
}

// ============================================
// GAME LOOP
// ============================================
let lastTime = performance.now();
let gameRunning = true;

function processTime(dt) {
  // Update mega boost timer
  if (megaBoostTimer > 0) {
    megaBoostTimer -= dt;
    if (megaBoostTimer <= 0) megaBoostTimer = 0;
  }

  // Update bars
  for (let bar of activeBars) {
    if (bar.completed) continue;

    bar.progress += bar.fillRate * dt;

    if (bar.progress >= 1) {
      bar.progress = 1;
      bar.fill.style.width = '100%';
      completeBar(bar);
    } else {
      bar.fill.style.width = (bar.progress * 100) + '%';
    }
  }
}

function gameLoop() {
  const now = performance.now();
  const dt = Math.min((now - lastTime) / 1000, 0.1);
  lastTime = now;

  processTime(dt);

  requestAnimationFrame(gameLoop);
}

// Background timer - runs even when tab unfocused (throttled to ~1Hz)
function backgroundTick() {
  if (document.hidden) {
    const now = performance.now();
    const dt = Math.min((now - lastTime) / 1000, 2); // Cap at 2 seconds per tick
    lastTime = now;
    processTime(dt);
    updateUI();
  }
}

// Catch up when tab becomes visible again
function handleVisibilityChange() {
  if (!document.hidden) {
    // Tab became visible - sync time
    lastTime = performance.now();
    updateUI();
    renderSidebar();
  }
}

document.addEventListener('visibilitychange', handleVisibilityChange);

// ============================================
// UPGRADE SYSTEM
// ============================================
function buyUpgrade(upgradeKey) {
  const upgrade = upgrades[upgradeKey];
  const currentLevel = upgrade.currentLevel;

  if (currentLevel >= upgrade.levels.length) return;

  const nextLevel = upgrade.levels[currentLevel];
  if (completedBars < nextLevel.cost) return;

  completedBars -= nextLevel.cost;
  upgrade.currentLevel++;
  upgrade.apply(nextLevel.value);

  updateUI();
  renderSidebar();
  saveGame(); // Immediate save after purchase
}

function unlockSpecialBar(barType) {
  const unlock = specialBarUnlocks[barType];
  if (unlock.unlocked) return;
  if (completedBars < unlock.cost) return;

  completedBars -= unlock.cost;
  unlock.unlocked = true;

  updateUI();
  renderSidebar();
  saveGame(); // Immediate save after unlock
}

function activateChaosPower(powerKey) {
  const power = chaosPowers[powerKey];
  if (chaosShards < power.cost) return;

  chaosShards -= power.cost;
  power.activate();

  updateUI();
  renderSidebar();
  saveGame(); // Immediate save after power use
}

// ============================================
// UI RENDERING
// ============================================
function formatNumber(num) {
  if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
  if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
  return Math.floor(num).toString();
}

function calculateBarsPerSecond() {
  let totalPerSecond = 0;

  for (const bar of activeBars) {
    if (bar.completed) continue;

    const depthBonus = 1 + (bar.depth * 0.5);
    let value = barsPerCompletion * depthBonus;

    // Apply mega boost if active
    if (megaBoostTimer > 0) value *= 3;

    // Value per second = value / remaining time
    const remainingProgress = 1 - bar.progress;
    const remainingTime = remainingProgress / bar.fillRate;

    if (remainingTime > 0) {
      totalPerSecond += value / remainingTime;
    }
  }

  return totalPerSecond;
}

function updateUI() {
  document.getElementById('completed-bars').textContent = formatNumber(completedBars);
  document.getElementById('manual-slots').textContent = manualBarsActive + '/' + maxManualSlots;
  document.getElementById('active-bars').textContent = activeBars.filter(b => !b.completed).length;
  document.getElementById('chaos-shards').textContent = formatNumber(chaosShards);
  document.getElementById('cooking-value').textContent = calculateBarsPerSecond().toFixed(1) + '/s';
}

function renderSidebar() {
  // Render upgrades
  const upgradesSection = document.getElementById('upgrades-section');
  upgradesSection.innerHTML = '<div class="section-title">Upgrades</div>';

  for (const [key, upgrade] of Object.entries(upgrades)) {
    const currentLevel = upgrade.currentLevel;
    const isMaxed = currentLevel >= upgrade.levels.length;
    const nextLevel = isMaxed ? null : upgrade.levels[currentLevel];
    const canAfford = nextLevel && completedBars >= nextLevel.cost;

    const item = document.createElement('div');
    item.className = 'upgrade-item' + (isMaxed ? ' maxed' : (!canAfford ? ' disabled' : ''));

    let valuesHtml = '';
    const currentValue = upgrade.getCurrentValue();

    if (isMaxed) {
      valuesHtml = `<span class="current-value">${upgrade.getDisplay(currentValue)}</span> <span style="color:#4ecca3">MAX</span>`;
    } else {
      valuesHtml = `<span class="current-value">${upgrade.getDisplay(currentValue)}</span> <span class="arrow">→</span> <span class="next-value">${upgrade.getDisplay(nextLevel.value)}</span>`;
    }

    item.innerHTML = `
      <div class="item-header">
        <span class="item-name">${upgrade.name}</span>
        <span class="item-level">${currentLevel}/${upgrade.levels.length}</span>
      </div>
      <div class="item-values">${valuesHtml}</div>
      ${!isMaxed ? `<div class="item-cost ${canAfford ? 'affordable' : ''}">Cost: ${formatNumber(nextLevel.cost)} bars</div>` : ''}
    `;

    if (!isMaxed && canAfford) {
      item.onclick = () => buyUpgrade(key);
    }

    upgradesSection.appendChild(item);
  }

  // Render unlocks
  const unlocksSection = document.getElementById('unlocks-section');
  unlocksSection.innerHTML = '<div class="section-title">Special Bars</div>';

  for (const [key, unlock] of Object.entries(specialBarUnlocks)) {
    const canAfford = completedBars >= unlock.cost;

    const item = document.createElement('div');
    item.className = 'unlock-item' + (unlock.unlocked ? ' unlocked' : (!canAfford ? ' disabled' : ''));

    item.innerHTML = `
      <div class="item-header">
        <span class="item-name">${unlock.name}</span>
        ${unlock.unlocked ? '<span class="unlock-badge">UNLOCKED</span>' : ''}
      </div>
      <div class="item-description">${unlock.description}</div>
      ${!unlock.unlocked ? `<div class="item-cost ${canAfford ? 'affordable' : ''}">Cost: ${formatNumber(unlock.cost)} bars</div>` : ''}
    `;

    if (!unlock.unlocked && canAfford) {
      item.onclick = () => unlockSpecialBar(key);
    }

    unlocksSection.appendChild(item);
  }

  // Render chaos powers
  const powersSection = document.getElementById('powers-section');
  powersSection.innerHTML = '<div class="section-title">Chaos Powers</div>';

  for (const [key, power] of Object.entries(chaosPowers)) {
    const canAfford = chaosShards >= power.cost;

    const item = document.createElement('div');
    item.className = 'power-item' + (!canAfford ? ' disabled' : '');

    let timerHtml = '';
    if (key === 'megaBoost' && megaBoostTimer > 0) {
      timerHtml = `<div class="power-timer">Active: ${Math.ceil(megaBoostTimer)}s</div>`;
    } else if (key === 'luckyStorm' && luckyStormCount > 0) {
      timerHtml = `<div class="power-timer">Remaining: ${luckyStormCount}</div>`;
    }

    item.innerHTML = `
      <div class="item-header">
        <span class="item-name">${power.name}</span>
      </div>
      <div class="item-description">${power.description}</div>
      <div class="item-cost shards ${canAfford ? 'affordable' : ''}">${power.cost} shards</div>
      ${timerHtml}
    `;

    if (canAfford) {
      item.onclick = () => activateChaosPower(key);
    }

    powersSection.appendChild(item);
  }
}

// ============================================
// INPUT HANDLING
// ============================================
function handleClick(e) {
  const playArea = document.getElementById('play-area');
  const rect = playArea.getBoundingClientRect();

  let x = e.clientX - rect.left - 70;
  let y = e.clientY - rect.top - 13;

  createBar(x, y, 0, true); // isManual = true
}

// ============================================
// INITIALIZATION
// ============================================
function init() {
  // Load saved game
  const loaded = loadGame();
  if (loaded) {
    console.log('Game loaded from save');
  }

  const playArea = document.getElementById('play-area');
  playArea.addEventListener('click', handleClick);
  playArea.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    handleClick({ clientX: touch.clientX, clientY: touch.clientY });
  });

  updateUI();
  renderSidebar();
  gameLoop();

  // Update sidebar periodically for timers
  setInterval(renderSidebar, 1000);

  // Background timer for when tab is unfocused
  setInterval(backgroundTick, 1000);

  // Auto-save every 5 seconds
  setInterval(saveGame, 5000);

  // Save on page unload
  window.addEventListener('beforeunload', saveGame);

  // Expose clearSave for debugging
  window.clearSave = clearSave;
  console.log('Tip: Call clearSave() in console to reset progress');
}

document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
