<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Progress Bar Clicker</title>
  <!--
    Progress Bar Clicker Game

    How to Play:
    1. Tap anywhere to spawn progress bars
    2. Bars fill automatically and award points when complete
    3. Tap the Upgrades button to buy upgrades
    4. Chain spawns create cascading bar reactions
    5. Watch for gold Boost bars - they multiply all active bar values!
  -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      touch-action: manipulation;
    }
    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: #1a1a1a;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<script>
// ============================================
// GAME STATE
// ============================================
let activeBars = [];
let floatingTexts = [];
let points = 0;
let modalOpen = false;

// Stats (modified by upgrades)
let pointMultiplier = 1;
let fillSpeed = 0.5;
let critChance = 0.05;
let chainChance = 0.05;
let maxChainDepth = 1;

// Layout constants - mobile portrait
const CANVAS_WIDTH = 400;
const CANVAS_HEIGHT = 700;
const TOP_BAR_HEIGHT = 50;

// Bar constants - smaller for mobile
const BAR_WIDTH = 120;
const BAR_HEIGHT = 22;
const BASE_POINTS = 10;

// Modal constants
const MODAL_PADDING = 20;
const MODAL_WIDTH = CANVAS_WIDTH - MODAL_PADDING * 2;
const MODAL_HEIGHT = 420;
const MODAL_X = MODAL_PADDING;
const MODAL_Y = (CANVAS_HEIGHT - MODAL_HEIGHT) / 2;

// ============================================
// UPGRADES
// ============================================
const upgrades = {
  pointGain: {
    name: 'Point Gain',
    level: 0,
    baseCost: 10,
    costGrowth: 1.15,
    getValue: () => pointMultiplier.toFixed(1) + 'x',
    effect: () => { pointMultiplier += 0.5; }
  },
  fillSpeed: {
    name: 'Fill Speed',
    level: 0,
    baseCost: 25,
    costGrowth: 1.2,
    getValue: () => fillSpeed.toFixed(2) + '/s',
    effect: () => { fillSpeed += 0.1; }
  },
  critChance: {
    name: 'Crit Chance',
    level: 0,
    baseCost: 50,
    costGrowth: 1.25,
    getValue: () => (critChance * 100).toFixed(0) + '%',
    effect: () => { critChance += 0.05; }
  },
  chainChance: {
    name: 'Chain Spawn',
    level: 0,
    baseCost: 100,
    costGrowth: 1.3,
    getValue: () => (chainChance * 100).toFixed(0) + '%',
    effect: () => { chainChance += 0.1; }
  },
  maxDepth: {
    name: 'Max Depth',
    level: 0,
    baseCost: 1000,
    costGrowth: 10,
    getValue: () => maxChainDepth.toString(),
    effect: () => { maxChainDepth += 1; }
  }
};

function getCost(upgradeKey) {
  const u = upgrades[upgradeKey];
  return Math.floor(u.baseCost * Math.pow(u.costGrowth, u.level));
}

function purchaseUpgrade(key) {
  const cost = getCost(key);
  if (points >= cost) {
    points -= cost;
    upgrades[key].level++;
    upgrades[key].effect();
  }
}

// ============================================
// PROGRESS BAR CLASS
// ============================================
class ProgressBar {
  constructor(x, y, barType = 'normal', depth = 0) {
    // Clamp position to keep bar on screen
    this.x = constrain(x, 0, CANVAS_WIDTH - BAR_WIDTH);
    this.y = constrain(y, TOP_BAR_HEIGHT + 5, CANVAS_HEIGHT - BAR_HEIGHT - 5);
    this.width = BAR_WIDTH;
    this.height = BAR_HEIGHT;
    this.progress = 0;
    this.barType = barType;
    this.depth = depth;
    this.pointValue = BASE_POINTS * pointMultiplier;
    this.currentFillSpeed = fillSpeed;
    this.completed = false;
    this.critFlash = false;
    this.critFlashTimer = 0;
  }

  update(dt) {
    // Update crit flash timer (must run even after completion)
    if (this.critFlash) {
      this.critFlashTimer -= dt;
      if (this.critFlashTimer <= 0) {
        this.critFlash = false;
      }
    }

    if (this.completed) return;

    // Fill the bar
    this.progress += this.currentFillSpeed * dt;

    if (this.progress >= 1) {
      this.progress = 1;
      this.onComplete();
    }
  }

  display() {
    // Background
    fill(68, 68, 68);
    stroke(255);
    strokeWeight(1.5);
    rect(this.x, this.y, this.width, this.height, 3);

    // Fill color based on type and state
    let fillColor;
    if (this.critFlash) {
      fillColor = color(255, 82, 82);
    } else if (this.barType === 'boost') {
      fillColor = color(255, 215, 0);
    } else {
      fillColor = color(76, 175, 80);
    }

    // Filled portion
    noStroke();
    fill(fillColor);
    rect(this.x + 2, this.y + 2, (this.width - 4) * this.progress, this.height - 4, 2);

    // Depth indicator
    if (this.depth > 0) {
      fill(255, 255, 255, 150);
      textSize(8);
      textAlign(LEFT, TOP);
      text('d' + this.depth, this.x + 4, this.y + 2);
    }
  }

  onComplete() {
    this.completed = true;

    let earnedPoints = this.pointValue;
    let isCrit = false;

    if (random(0, 1) < critChance) {
      earnedPoints *= 2;
      isCrit = true;
      this.critFlash = true;
      this.critFlashTimer = 0.2;
    }

    points += earnedPoints;
    spawnFloatingText(this.x + this.width / 2, this.y, earnedPoints, isCrit);

    if (this.barType === 'boost') {
      for (let bar of activeBars) {
        if (!bar.completed) {
          bar.pointValue *= 1.5;
        }
      }
      spawnFloatingText(this.x + this.width / 2, this.y - 15, 'BOOST!', false, color(255, 215, 0));
    }

    this.rollChains();
  }

  rollChains() {
    if (this.depth >= maxChainDepth) return;

    let chainsToSpawn = Math.floor(chainChance);
    let remainingChance = chainChance % 1;

    if (random(0, 1) < remainingChance) {
      chainsToSpawn += 1;
    }

    for (let i = 0; i < chainsToSpawn; i++) {
      spawnBar(
        random(0, CANVAS_WIDTH - BAR_WIDTH),
        random(TOP_BAR_HEIGHT + 5, CANVAS_HEIGHT - BAR_HEIGHT - 5),
        this.depth + 1
      );
    }
  }
}

// ============================================
// FLOATING TEXT CLASS
// ============================================
class FloatingText {
  constructor(x, y, text, isCrit = false, customColor = null) {
    this.x = x;
    this.y = y;
    this.text = typeof text === 'number' ? '+' + Math.floor(text) : text;
    this.alpha = 255;
    this.size = isCrit ? 18 : 12;
    this.color = customColor || (isCrit ? color(255, 82, 82) : color(255, 255, 255));
    this.velocity = -50;
  }

  update(dt) {
    this.y += this.velocity * dt;
    this.alpha -= 200 * dt;
  }

  display() {
    if (this.alpha <= 0) return;
    let c = this.color;
    fill(red(c), green(c), blue(c), this.alpha);
    noStroke();
    textSize(this.size);
    textAlign(CENTER, CENTER);
    text(this.text, this.x, this.y);
  }

  isDead() {
    return this.alpha <= 0;
  }
}

function spawnFloatingText(x, y, text, isCrit = false, customColor = null) {
  floatingTexts.push(new FloatingText(x, y, text, isCrit, customColor));
  if (floatingTexts.length > 50) {
    floatingTexts.shift();
  }
}

// ============================================
// BAR SPAWNING
// ============================================
function spawnBar(x, y, depth = 0) {
  let barType = random(0, 1) < 0.03 ? 'boost' : 'normal';
  activeBars.push(new ProgressBar(x, y, barType, depth));
}

// ============================================
// UI RENDERING
// ============================================
function drawTopBar() {
  // Background
  fill(40, 40, 40);
  noStroke();
  rect(0, 0, CANVAS_WIDTH, TOP_BAR_HEIGHT);

  // Points display
  fill(255);
  textSize(20);
  textAlign(LEFT, CENTER);
  text(formatNumber(Math.floor(points)), 12, TOP_BAR_HEIGHT / 2);

  // Bar count
  textSize(11);
  fill(180);
  textAlign(CENTER, CENTER);
  text(activeBars.length + ' bars', CANVAS_WIDTH / 2, TOP_BAR_HEIGHT / 2);

  // Upgrades button
  const btnWidth = 80;
  const btnHeight = 32;
  const btnX = CANVAS_WIDTH - btnWidth - 10;
  const btnY = (TOP_BAR_HEIGHT - btnHeight) / 2;

  fill(70, 130, 180);
  stroke(100, 160, 210);
  strokeWeight(1.5);
  rect(btnX, btnY, btnWidth, btnHeight, 6);

  fill(255);
  noStroke();
  textSize(12);
  textAlign(CENTER, CENTER);
  text('Upgrades', btnX + btnWidth / 2, btnY + btnHeight / 2);

  // Store button bounds
  window.upgradesBtnBounds = { x: btnX, y: btnY, w: btnWidth, h: btnHeight };
}

function drawModal() {
  // Dim background
  fill(0, 0, 0, 180);
  noStroke();
  rect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

  // Modal background
  fill(45, 45, 45);
  stroke(80, 80, 80);
  strokeWeight(2);
  rect(MODAL_X, MODAL_Y, MODAL_WIDTH, MODAL_HEIGHT, 10);

  // Header
  fill(255);
  textSize(18);
  textAlign(CENTER, TOP);
  text('UPGRADES', CANVAS_WIDTH / 2, MODAL_Y + 12);

  // Points display in modal
  textSize(14);
  fill(180, 255, 180);
  text('Points: ' + formatNumber(Math.floor(points)), CANVAS_WIDTH / 2, MODAL_Y + 36);

  // Close button (X)
  const closeSize = 28;
  const closeX = MODAL_X + MODAL_WIDTH - closeSize - 8;
  const closeY = MODAL_Y + 8;

  fill(100, 60, 60);
  stroke(150, 80, 80);
  strokeWeight(1);
  rect(closeX, closeY, closeSize, closeSize, 4);

  fill(255);
  noStroke();
  textSize(16);
  textAlign(CENTER, CENTER);
  text('X', closeX + closeSize / 2, closeY + closeSize / 2);

  window.closeBtnBounds = { x: closeX, y: closeY, w: closeSize, h: closeSize };

  // Draw upgrade buttons
  let buttonY = MODAL_Y + 60;
  const buttonHeight = 58;
  const buttonPadding = 8;
  const buttonWidth = MODAL_WIDTH - 24;
  const buttonX = MODAL_X + 12;

  const keys = Object.keys(upgrades);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    const u = upgrades[key];
    const cost = getCost(key);
    const affordable = points >= cost;

    u.buttonBounds = { x: buttonX, y: buttonY, w: buttonWidth, h: buttonHeight };

    // Button background
    if (affordable) {
      fill(50, 85, 50);
      stroke(80, 140, 80);
    } else {
      fill(55, 55, 55);
      stroke(70, 70, 70);
    }
    strokeWeight(1.5);
    rect(buttonX, buttonY, buttonWidth, buttonHeight, 6);

    // Name and level
    fill(255);
    noStroke();
    textSize(13);
    textAlign(LEFT, TOP);
    text(u.name + ' (Lv ' + u.level + ')', buttonX + 10, buttonY + 8);

    // Current value - right aligned
    textAlign(RIGHT, TOP);
    fill(200, 200, 200);
    text(u.getValue(), buttonX + buttonWidth - 10, buttonY + 8);

    // Cost
    textAlign(LEFT, BOTTOM);
    fill(affordable ? color(120, 255, 120) : color(140, 140, 140));
    textSize(12);
    text('Cost: ' + formatNumber(cost), buttonX + 10, buttonY + buttonHeight - 8);

    buttonY += buttonHeight + buttonPadding;
  }
}

function formatNumber(num) {
  if (num >= 1000000) {
    return (num / 1000000).toFixed(2) + 'M';
  } else if (num >= 1000) {
    return (num / 1000).toFixed(2) + 'K';
  }
  return num.toString();
}

// ============================================
// P5.JS LIFECYCLE
// ============================================
function setup() {
  createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
  textFont('sans-serif');
}

function draw() {
  let dt = deltaTime / 1000;
  dt = min(dt, 0.1);

  background(42, 42, 42);

  // Update and filter bars
  for (let bar of activeBars) {
    bar.update(dt);
  }
  activeBars = activeBars.filter(bar => !bar.completed || bar.critFlash);

  // Display bars
  for (let bar of activeBars) {
    bar.display();
  }

  // Update and display floating texts
  for (let ft of floatingTexts) {
    ft.update(dt);
    ft.display();
  }
  floatingTexts = floatingTexts.filter(ft => !ft.isDead());

  // Draw UI
  drawTopBar();

  // Draw modal if open
  if (modalOpen) {
    drawModal();
  }
}

function mousePressed() {
  handleInput(mouseX, mouseY);
}

function touchStarted() {
  if (touches.length > 0) {
    handleInput(touches[0].x, touches[0].y);
  }
  return false; // Prevent default
}

function handleInput(x, y) {
  // If modal is open, handle modal interactions
  if (modalOpen) {
    // Check close button
    const cb = window.closeBtnBounds;
    if (cb && x >= cb.x && x <= cb.x + cb.w && y >= cb.y && y <= cb.y + cb.h) {
      modalOpen = false;
      return;
    }

    // Check upgrade buttons
    const keys = Object.keys(upgrades);
    for (let key of keys) {
      const u = upgrades[key];
      const b = u.buttonBounds;
      if (b && x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
        purchaseUpgrade(key);
        return;
      }
    }

    // Click outside modal closes it
    if (x < MODAL_X || x > MODAL_X + MODAL_WIDTH || y < MODAL_Y || y > MODAL_Y + MODAL_HEIGHT) {
      modalOpen = false;
    }
    return;
  }

  // Check upgrades button
  const ub = window.upgradesBtnBounds;
  if (ub && x >= ub.x && x <= ub.x + ub.w && y >= ub.y && y <= ub.y + ub.h) {
    modalOpen = true;
    return;
  }

  // Check if in top bar
  if (y < TOP_BAR_HEIGHT) {
    return;
  }

  // Spawn bar at tap position
  spawnBar(x - BAR_WIDTH / 2, y - BAR_HEIGHT / 2);
}
</script>
</body>
</html>
