<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Progress Bar Clicker</title>
  <!--
    Progress Bar Clicker Game

    How to Play:
    1. Click anywhere in the dark game area to spawn progress bars
    2. Bars fill automatically and award points when complete
    3. Use points to buy upgrades in the right sidebar
    4. Chain spawns create cascading bar reactions
    5. Watch for gold Boost bars - they multiply all active bar values!

    Tips:
    - Crits flash red and give 2x points
    - Chain Chance > 100% guarantees multiple spawns
    - Max Chain Depth controls how deep cascades can go
  -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: #1a1a1a;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<script>
// ============================================
// GAME STATE
// ============================================
let activeBars = [];
let floatingTexts = [];
let points = 0;

// Stats (modified by upgrades)
let pointMultiplier = 1;
let fillSpeed = 0.5;
let critChance = 0.05;
let chainChance = 0.05;
let maxChainDepth = 1;

// Layout constants
const CANVAS_WIDTH = 1200;
const CANVAS_HEIGHT = 800;
const TOP_BAR_HEIGHT = 60;
const SIDEBAR_WIDTH = 200;
const GAME_AREA_WIDTH = CANVAS_WIDTH - SIDEBAR_WIDTH;

// Bar constants
const BAR_WIDTH = 200;
const BAR_HEIGHT = 30;
const BASE_POINTS = 10;

// ============================================
// UPGRADES
// ============================================
const upgrades = {
  pointGain: {
    name: 'Point Gain',
    level: 0,
    baseCost: 10,
    costGrowth: 1.15,
    getValue: () => pointMultiplier.toFixed(1) + 'x',
    effect: () => { pointMultiplier += 0.5; }
  },
  fillSpeed: {
    name: 'Fill Speed',
    level: 0,
    baseCost: 25,
    costGrowth: 1.2,
    getValue: () => fillSpeed.toFixed(2) + '/s',
    effect: () => { fillSpeed += 0.1; }
  },
  critChance: {
    name: 'Crit Chance',
    level: 0,
    baseCost: 50,
    costGrowth: 1.25,
    getValue: () => (critChance * 100).toFixed(0) + '%',
    effect: () => { critChance += 0.05; }
  },
  chainChance: {
    name: 'Chain Spawn',
    level: 0,
    baseCost: 100,
    costGrowth: 1.3,
    getValue: () => (chainChance * 100).toFixed(0) + '%',
    effect: () => { chainChance += 0.1; }
  },
  maxDepth: {
    name: 'Max Depth',
    level: 0,
    baseCost: 1000,
    costGrowth: 10,
    getValue: () => maxChainDepth.toString(),
    effect: () => { maxChainDepth += 1; }
  }
};

function getCost(upgradeKey) {
  const u = upgrades[upgradeKey];
  return Math.floor(u.baseCost * Math.pow(u.costGrowth, u.level));
}

function purchaseUpgrade(key) {
  const cost = getCost(key);
  if (points >= cost) {
    points -= cost;
    upgrades[key].level++;
    upgrades[key].effect();
  }
}

// ============================================
// PROGRESS BAR CLASS
// ============================================
class ProgressBar {
  constructor(x, y, barType = 'normal', depth = 0) {
    // Clamp position to keep bar on screen
    this.x = constrain(x, 0, GAME_AREA_WIDTH - BAR_WIDTH);
    this.y = constrain(y, TOP_BAR_HEIGHT, CANVAS_HEIGHT - BAR_HEIGHT);
    this.width = BAR_WIDTH;
    this.height = BAR_HEIGHT;
    this.progress = 0;
    this.barType = barType;
    this.depth = depth;
    this.pointValue = BASE_POINTS * pointMultiplier;
    this.currentFillSpeed = fillSpeed;
    this.completed = false;
    this.critFlash = false;
    this.critFlashTimer = 0;
  }

  update(dt) {
    // Update crit flash timer (must run even after completion)
    if (this.critFlash) {
      this.critFlashTimer -= dt;
      if (this.critFlashTimer <= 0) {
        this.critFlash = false;
      }
    }

    if (this.completed) return;

    // Fill the bar
    this.progress += this.currentFillSpeed * dt;

    if (this.progress >= 1) {
      this.progress = 1;
      this.onComplete();
    }
  }

  display() {
    // Background
    fill(68, 68, 68);
    stroke(255);
    strokeWeight(2);
    rect(this.x, this.y, this.width, this.height);

    // Fill color based on type and state
    let fillColor;
    if (this.critFlash) {
      fillColor = color(255, 82, 82); // Red for crit
    } else if (this.barType === 'boost') {
      fillColor = color(255, 215, 0); // Gold for boost
    } else {
      fillColor = color(76, 175, 80); // Green for normal
    }

    // Filled portion
    noStroke();
    fill(fillColor);
    rect(this.x + 2, this.y + 2, (this.width - 4) * this.progress, this.height - 4);

    // Depth indicator (small number in corner for chain depth)
    if (this.depth > 0) {
      fill(255, 255, 255, 150);
      textSize(10);
      textAlign(LEFT, TOP);
      text('d' + this.depth, this.x + 5, this.y + 3);
    }
  }

  onComplete() {
    this.completed = true;

    let earnedPoints = this.pointValue;
    let isCrit = false;

    // Roll for crit
    if (random(0, 1) < critChance) {
      earnedPoints *= 2;
      isCrit = true;
      this.critFlash = true;
      this.critFlashTimer = 0.2;
    }

    // Award points
    points += earnedPoints;

    // Spawn floating text
    spawnFloatingText(this.x + this.width / 2, this.y, earnedPoints, isCrit);

    // Boost bar effect: multiply all active bars' point values
    if (this.barType === 'boost') {
      for (let bar of activeBars) {
        if (!bar.completed) {
          bar.pointValue *= 1.5;
        }
      }
      // Flash effect for boost
      spawnFloatingText(this.x + this.width / 2, this.y - 20, 'BOOST!', false, color(255, 215, 0));
    }

    // Roll for chain spawns
    this.rollChains();
  }

  rollChains() {
    if (this.depth >= maxChainDepth) return;

    let chainsToSpawn = Math.floor(chainChance);
    let remainingChance = chainChance % 1;

    if (random(0, 1) < remainingChance) {
      chainsToSpawn += 1;
    }

    for (let i = 0; i < chainsToSpawn; i++) {
      spawnBar(
        random(0, GAME_AREA_WIDTH - BAR_WIDTH),
        random(TOP_BAR_HEIGHT, CANVAS_HEIGHT - BAR_HEIGHT),
        this.depth + 1
      );
    }
  }
}

// ============================================
// FLOATING TEXT CLASS
// ============================================
class FloatingText {
  constructor(x, y, text, isCrit = false, customColor = null) {
    this.x = x;
    this.y = y;
    this.text = typeof text === 'number' ? '+' + Math.floor(text) : text;
    this.alpha = 255;
    this.size = isCrit ? 24 : 16;
    this.color = customColor || (isCrit ? color(255, 82, 82) : color(255, 255, 255));
    this.velocity = -60; // pixels per second upward
  }

  update(dt) {
    this.y += this.velocity * dt;
    this.alpha -= 200 * dt;
  }

  display() {
    if (this.alpha <= 0) return;
    let c = this.color;
    fill(red(c), green(c), blue(c), this.alpha);
    noStroke();
    textSize(this.size);
    textAlign(CENTER, CENTER);
    text(this.text, this.x, this.y);
  }

  isDead() {
    return this.alpha <= 0;
  }
}

function spawnFloatingText(x, y, text, isCrit = false, customColor = null) {
  floatingTexts.push(new FloatingText(x, y, text, isCrit, customColor));
  // Limit floating texts to prevent memory issues
  if (floatingTexts.length > 100) {
    floatingTexts.shift();
  }
}

// ============================================
// BAR SPAWNING
// ============================================
function spawnBar(x, y, depth = 0) {
  // 3% chance for boost bar
  let barType = random(0, 1) < 0.03 ? 'boost' : 'normal';
  activeBars.push(new ProgressBar(x, y, barType, depth));
}

// ============================================
// UI RENDERING
// ============================================
function drawTopBar() {
  // Background
  fill(40, 40, 40);
  noStroke();
  rect(0, 0, CANVAS_WIDTH, TOP_BAR_HEIGHT);

  // Points display
  fill(255);
  textSize(32);
  textAlign(LEFT, CENTER);
  text('Points: ' + formatNumber(Math.floor(points)), 20, TOP_BAR_HEIGHT / 2);

  // Bar count
  textSize(16);
  textAlign(RIGHT, CENTER);
  text('Active Bars: ' + activeBars.length, GAME_AREA_WIDTH - 20, TOP_BAR_HEIGHT / 2);
}

function drawSidebar() {
  // Background
  fill(50, 50, 50);
  noStroke();
  rect(GAME_AREA_WIDTH, 0, SIDEBAR_WIDTH, CANVAS_HEIGHT);

  // Title
  fill(255);
  textSize(20);
  textAlign(CENTER, TOP);
  text('UPGRADES', GAME_AREA_WIDTH + SIDEBAR_WIDTH / 2, 15);

  // Draw upgrade buttons
  let buttonY = 50;
  const buttonHeight = 70;
  const buttonPadding = 10;
  const buttonWidth = SIDEBAR_WIDTH - 20;

  const keys = Object.keys(upgrades);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    const u = upgrades[key];
    const cost = getCost(key);
    const affordable = points >= cost;

    // Store button bounds for click detection
    u.buttonY = buttonY;
    u.buttonHeight = buttonHeight;

    // Button background
    if (affordable) {
      fill(60, 100, 60); // Green tint if affordable
    } else {
      fill(60, 60, 60); // Gray if not
    }
    stroke(affordable ? color(100, 180, 100) : color(80, 80, 80));
    strokeWeight(2);
    rect(GAME_AREA_WIDTH + 10, buttonY, buttonWidth, buttonHeight, 5);

    // Upgrade name and level
    fill(255);
    noStroke();
    textSize(14);
    textAlign(LEFT, TOP);
    text(u.name + ' (Lv ' + u.level + ')', GAME_AREA_WIDTH + 18, buttonY + 8);

    // Current value
    textSize(12);
    fill(200, 200, 200);
    text('Current: ' + u.getValue(), GAME_AREA_WIDTH + 18, buttonY + 28);

    // Cost
    fill(affordable ? color(100, 255, 100) : color(150, 150, 150));
    text('Cost: ' + formatNumber(cost), GAME_AREA_WIDTH + 18, buttonY + 46);

    buttonY += buttonHeight + buttonPadding;
  }
}

function formatNumber(num) {
  if (num >= 1000000) {
    return (num / 1000000).toFixed(2) + 'M';
  } else if (num >= 1000) {
    return (num / 1000).toFixed(2) + 'K';
  }
  return num.toString();
}

// ============================================
// P5.JS LIFECYCLE
// ============================================
function setup() {
  createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
}

function draw() {
  // Delta time in seconds
  let dt = deltaTime / 1000;

  // Cap delta time to prevent huge jumps
  dt = min(dt, 0.1);

  // Clear background
  background(42, 42, 42);

  // Update and filter bars
  for (let bar of activeBars) {
    bar.update(dt);
  }

  // Remove completed bars (after crit flash finishes)
  activeBars = activeBars.filter(bar => !bar.completed || bar.critFlash);

  // Display bars
  for (let bar of activeBars) {
    bar.display();
  }

  // Update and display floating texts
  for (let ft of floatingTexts) {
    ft.update(dt);
    ft.display();
  }
  floatingTexts = floatingTexts.filter(ft => !ft.isDead());

  // Draw UI on top
  drawTopBar();
  drawSidebar();
}

function mousePressed() {
  // Check if click is in sidebar (upgrade buttons)
  if (mouseX > GAME_AREA_WIDTH) {
    const keys = Object.keys(upgrades);
    for (let key of keys) {
      const u = upgrades[key];
      if (u.buttonY !== undefined) {
        if (mouseY >= u.buttonY && mouseY <= u.buttonY + u.buttonHeight) {
          purchaseUpgrade(key);
          return;
        }
      }
    }
    return;
  }

  // Check if click is in top bar (ignore)
  if (mouseY < TOP_BAR_HEIGHT) {
    return;
  }

  // Spawn bar at click position
  spawnBar(mouseX - BAR_WIDTH / 2, mouseY - BAR_HEIGHT / 2);
}
</script>
</body>
</html>
